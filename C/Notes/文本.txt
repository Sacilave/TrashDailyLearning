存储类：
	存储分类：
		寄存器：用于暂存数据，适用于小数据，速度更快
		存储器：RAM，ROM
	
	定义了变量或函数的 存储位置，生命周期，作用域
	auto：
		是局部变量的默认储存类型，随函数结束而结束，只能在函数内，只能修饰局部变量
	register:
		用于定义存储在寄存器的数据，没有内存数据(所以不能使用位运算)，常用于计数器

	
		

常量：
	const int VALUENAME 声明指定类型常量，会在程序运行时分配内存并且有类型信息，调试时可用，作用域为声明所在作用域
	#define VALUENAME 声明无类型常量，仅在编译时直接替换为相应的值，作用域为整个代码

	字符串常量在内存中必存在两个字符，末尾有\0作为结束标志，使用双引号标识
	字符常量为单字节，使用单引号标识

占位符：
	各类型占位符：
		%p 用于指针，输出这个指针
		%u 用于无符号整型
	在 printf 中：
		%xn  x 为一个数字，n为输出类型
		x 为整数时表示以多少位输出，前方可能出现空格。
		.x 形式表示输出小数点后x位
		x 前加 - 表示从右开始缩进位数
		x 前加 0 表示以 0 代替占位的空格
		n为 f，d，u，c，s，e 分别表示 小数，整数，无符号整数，字符，字符串，科学计数法方式输出
	在 scanf 中：
		%xn  x 表示限制位数  如 scanf("%2d%3d", a, b);
		x 前加 * 为不读符号，%*4d 表示四个字符都不读
		%c 中 空格和转义字符作为有效字符输入，否则数据结束符号为  1.遇到非法字符 2. 位数达到限制 3.遇到空格，回车，TAB

变量类型：
	整数：
		char, int, short, long
		unsigned 限制范围从0开始 为无符号整型
		八进制数以0开始，包括0~7的数字
		16进制数以0x开始，a~f表示了10~15的数字
		长整型末尾加L
		无符号末尾加U

	浮点数：
		浮点数存储为 符号位，指数位(阶码)，尾数位。分别存储正负，小数点前有几位数，浮点数中的全部数字
		float, double, long double
		float类型只能存7位，包括整数位和小数位

	
	数组：
		int 数组名[数组长度+1] = {1, 2, 3, 4, 5, ...} +1为数组最后必须为0的结束符
		对于字符串的数组赋值 char a[7] = "asdfgh"  或者  char a[7] = {'a','b', ...}

	全局变量和局部变量：
		作用域区别，全局变量作用于整个项目中，局部函数作用于所在函数

	静态变量：使用 static 关键字定义，声明变量默认值为 0 
		静态局部变量：所在函数第一次调用出现，不会随调用结束而结束，每次调用所在函数开始时值依旧为上一次调用结束的值，作用域为所在函数
		静态全局变量：类似全局变量，但作用域为当前文件，有效防止项目内变量名重名问题

	类型定义：使用 typedef 定义一个新的数据类型
		typedef exitingType newTypeName  比如  typeodef int NEWNUMTYPE  , 创建新类型使用全大写
		然后可以使用 NEWNUMTYPE 类型定义新变量，NEWNUMTYPE a = 1;

	枚举类型搭配类型定义：
		typedef enum {
			true,
			false
		}BOOLEAN;
		typedef enum {
			Monday,
			tuesday,
			wednesday,
			thursday,
			friday,
			saturday,
			sunday
		}WEEKDAY;
		枚举类型中每个枚举项都对应了从零开始的一个整数
		无法直接使用 printf 输出 enum，可用 case 判断值后输出

	结构体：
		使用 struct 
		struct person {
			int age;
			char *name;
		};  // 建立了一个名为 person 的结构体
		struct person steve = { 33, "Steve" }  // 声明并赋值了变量 steve
		steve.age = 20;  // 可以使用 . 语句访问结构体变量内的值
		引用传递：结构体是 复制传递 的，可以传递一个指向结构体的指针，这种情况下它就是引用传递
		使用 typedef 简化结构体代码： 类似枚举类型
			typedef struct {
				int age;
				char *name;
			} PERSON;
			PERSON steve = { 37, "Steve" }  // 声明并赋值变量

	类型转换：
		隐式类型转换
		显示类型转换：
			例如： double d = 2.00013; int a = (int)d;
			char类型 显式转换为 int 时为 ASCII 值




运算符：
	算数运算符：
		= + - * / %
		自增减：
			a++ 在使用 a 之后才自增它的值，而 ++a 会在使用 a 之前自增它的值
			b = a++ -> b = a, a++
			b = ++a -> a++, b = a
	比较运算符：

	逻辑运算符：! && ||
	
	二进制的存储方式：
		原码：
			正数 为 转换为 二进制的数，负数为绝对值转化为二进制，最高位补 1 
		反码：
			正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反
		补码：
			正数的补码与原码相同，负数的补码为该数的反码在最后一位加 1

		正数：原码表示
			无 unsigned 标记类型所有位都为数据存储位，如 unsigned int 为 32位，范围为 0 ~ 2^32
			有符号类型 第一位 为 符号位，如 int 为32位，但第一位为符号位，范围为 -2^31 ~ 2^31
		负数：
			使用该数原码的补码表示	

	位运算符：
		& 与
		| 或
		^ 异或  0^1为1，0^0为0，1^1为0
		~ 取反
		<< 左移
		>> 右移

	三目运算符：
		<条件> ? <表达式> : <表达式>
		若 a 的值为 true，就执行语句 b，否则执行语句 c

条件语句：
	if语句：
		if (条件) {		
		}
		else if (条件) {
		}
		else {
		}
	switch:
		int a = 1;
		switch (a) {
		  case 0:
			/* 进行一些操作 */
			break;
		  case 1:
			/* 进行另一些操作 */
			break;
		  case 2:
			/* 进行另一些操作 */
			break;
		  default:
			/* 处理所有其它的情况 */
			break;
		}

循环语句：
	for循环：
		for (int i = 0; i <= 10; i++) {
		/* 反复执行的指令 */
		}
	while循环：
		int i = 0;
		while (i < 10) {
		  /* 做点事情 */

		  i++;
		}
	do while循环：
		int i = 0;
		do {
		  /* 做点事情 */

		  i++;
		} while (i < 10);

指针：
	&变量名 为该变量地址
	*变量名 为创建该变量的指针
	int *address = &value01
	printf("%u", *address) 可以输出该指针地址
	对于列表来说，指针地址是连续的，int prices[5] = {0, 1, 2, 3, 4}
	printf("%u", (*prices + 1))可以输出列表中第二个值


函数：
	C语言的函数声明中的参数不能定义默认值但是C++中可以
	对于函数内的变量，变量在调用该函数的那一刻创建，并且在函数退出的时候销毁。它对函数外面来说是不可见的



内置函数体：
	putchar(c) 输出单个字符c，c可为任意单个字符


转义字符：
	\t 为一个TAB

头文件：
	#include 为预处理指令 #include <stdio.h> 会在标准库中自动寻找 stdio.h 头文件
	引用自己的头文件时使用 "" 其中可包含文件路径

预处理器：
	#define 可在开始定义 符号常量
	#define 函数名(x) (x*x)  // 此时定义了一个 宏，函数名常为全大写，宏相比函数在于，宏为单行操作
	int a = 函数名(4)  // 此处调用了定义的 宏，传递值为 4 最终 a 被赋值为 4*4




内置函数：
	延迟功能：
		Sleep(): 属于 Windows.h 头文件，在 gcc编译器中 可能因为版本不同使用的头文件也不同，在 VC 中函数名 S 大写，其余环境中不用。Sleep()单位为ms，sleep()单位为s。会挂起，把处理器让给其他进程
		delay(): 属于 dos.h 头文件，单位为ms。为循环等待，进程还在进行，依旧占用处理器
	强制退出：
		exit(): 属于 stdlib.h 头文件，需要传递一个 int 类型，传递 0 则程序返回值为 0，-1 则返回 -1
